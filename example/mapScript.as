package {	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.text.TextField;		import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.getTimer;		import flash.display.StageQuality;		public class mapScript extends Sprite {			//Declare global variables			private var level:Array = new Array();			private var tile:Sprite;			private var tileSize:int = 16;						private var scr1:Sprite;						private var player:Sprite;			//PLAYER CONTROLS					private var press_left:Boolean = false;					private var press_right:Boolean = false;					private var press_up:Boolean = false;					private var press_down:Boolean = false;					private var press_space:Boolean = false;										private var current_tile:Number;					private var over:String = "air";					private var falling:Boolean = false;										//GET EDGES			private var bottom:int;			private var left:int;			private var right:int;			private var top:int;			private var bottom_left:Number;			private var bottom_right:Number;			private var top_left:Number;			private var top_right:Number;						private var ground_acceleration:Number = 1;		private var ground_friction:Number = 0.8;		private var air_acceleration:Number = 0.5;		private var air_friction:Number = 0.7;								private var max_speed:Number = 3;			private var xspeed:Number = 0;			private var walking:Boolean = false;			private var x_pos:int = 0;			private var y_pos:int = 0;			private var speed:Number = 6;			private var friction:Number = 0.5;						private var timeStamp:int = 0;						//MAP BUILDING			private var countTile:Number = 0;			private var tilesAndDir:Array = new Array(); //Stores the number of Tiles in Each Object and their direction			private var numtilesAndDirs:Number = 0;			private var count:Number = 0;			private var dir:int = 0;						//SCREEN SCROLLING			private var scr:Sprite;			private var sOffx:int = 0; //How much the screen placement off set on the stage			private var sOffy:int = 0; //How much the screen placement off set on the stage			private var sX:int = 0;			private var sY:int = 0;			private var areaX:Number = 0;			private var areaY:Number = 0;			private var a:Array = new Array();			private var sW:Number = 0; //screen width			private var sH:Number = 0; //screen height			private var ax:Number = 0; //area the screen is in currently			private var ay:Number = 0; //area the screen is in currently			private var xPos:Number = 0; //Position of Screen			private var yPos:Number = 0; //Position of Screen			private var oldax:int = 0; //Area [x]			private var olday:int = 0; //Area [x][y]			private var t:Array = new Array(); //t[obj][numbOfTiles]			//Create our Tiles Array like the example			private var oX:Array = new Array(); //Xposition			private var oY:Array = new Array(); //Yposition			private var oTiles:Array = new Array(); //Type of tiles in the object			private var oW:Array = new Array(); //Xposition + width of tile			private var oH:Array = new Array(); //Yposition + height of tile			private var ar:Array = new Array(); //Area's			private var oV:Array = new Array(); // Visibility of the object (Is it on screen?)			private var v:Array = new Array(); //visible objects in the screen			private var save:Array = new Array(); //save the visible objects for reseting			private var obj:int = 0; //object number									//Bitmap Tile Types stored in an Array			private var tileSprite:Array = [T16, V32, V48, V64, V80, V96, T16, H32, H48, H64, H80, H96];						private var myText:URLLoader = new URLLoader();								//FPS		private var time:int;        private var prevTime:int = 0;        private var fps:int;        private var fps_txt:TextField;				public function mapScript() {			init();						stage.quality = StageQuality.LOW; //Set to low quality for extra speed		}						private function init():void {			//init function						//Frames Per Second            fps_txt = new TextField();            addChild(fps_txt);			fps_txt.x = 0;			fps_txt.y = 0;			//THE LEVEL			level[0] =  [1, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];			level[1] =  [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2];			level[2] =  [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];			level[3] =  [1, 0, 3, 0, 1, 0, 1, 2, 2, 2, 2, 1, 0, 0, 1, 2, 2, 2, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0];			level[4] =  [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 2, 2, 2, 1, 0, 0, 1, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 0, 2, 2, 2, 2, 1, 0, 0, 1, 2, 2, 2, 0, 0];			level[5] =  [2, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 1];			level[6] =  [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1];			level[7] =  [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];			level[8] =  [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0];			level[9] =  [2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0, 1];			level[10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1];			level[11] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1];			level[12] = [2, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];			level[13] = [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1];			level[14] = [2, 2, 2, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 2, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0];			level[15] = [2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 1, 2, 2, 2, 1, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1];			level[16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0];			level[17] = [2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0, 1];			level[18] = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1];			level[19] = [1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 1, 2, 2, 2, 1];									//Count the length of the level height and width			var mapWidth = level[0].length;			var mapHeight = level.length;						//Create Screen Width & Height			sW = int(256); //Half the Screen			sH = int(192); //Half the Screen						trace("map_size: " + mapWidth * tileSize);			trace("Screen Width: " + sW + " Screen Height: " + sH);			//Create a Screen			scr = new Sprite();			addChild(scr);			scr.x = 0;			scr.y = 0;												//Show bounding box of the screen			//scr1 = new screen;			//scr1.x = sOffx;			//scr1.y = sOffx;			//addChild(scr1);									//Main Arrays						//Count Tiles // Create Hero			var count:int = 0;			for ( var column3:int = 0; column3 < mapWidth; column3++)			{				for ( var row3:int = 0; row3 < mapHeight; row3++)				{					if (level[row3][column3] == 1) { count += 1};					if (level[row3][column3] == 2) { count += 1};										//Create The Hero					if (level[row3][column3] == 3) {					player = new hero;					scr.addChild(player);					x_pos = int(column3 * tileSize);					y_pos = int(row3 * tileSize);					}				}							}			trace("total number of tiles: " + count);			/*The following piece of Code runs through the level Array Vertically, counts all the tiles in encounters, logs their starting positions on the map.*/												//Convert the Vertical Tile types in the Array into Map Data			for ( var column:int = 0; column < mapWidth; column++)			{				for ( var row:int = 0; row < mapHeight; row++)				{					//If there is a tile[1] in the Array					if (level[row][column] == 1)						{ countTile += 1; } //count how many tiles were in a row															if (row == mapHeight - 1) //If we reach the end of the column. Save the map data we have stored					{						if (countTile >= 1)							{							tilesAndDir.push(countTile); //Add the number of consequentive tiles to an array called tilesAndDir														areaX = column; //Save the X position of the found tiles							areaY = (row - (countTile - 1)); //Correct Starting Position. Subtract the number of counted tiles from the final position to find the original starting position														oX.push(areaX * tileSize);							oY.push(areaY * tileSize);							oW.push(tileSize);							oH.push(countTile * tileSize);														tilesAndDir.push(0); // If the tilesAndDir is a vertical column. Record it as [0], if it is horizontal [1]							}												countTile = 0; //Reset the tile counter					} //End of Function - If we reach the end of the column																				if (countTile >= 1) //If we have counted 1 or more tiles then we hit a tile[0] or a tile[2] Record the data into the tilesAndDir Array like previously					{						if (level[row][column] == 0) //Then we hit a area which has no tile designated to it						{							tilesAndDir.push(countTile); //Add what we have to the tilesAndDir Array							areaX = column;							areaY = (row - countTile); //Correct Starting Position														oX.push(areaX * tileSize);							oY.push(areaY * tileSize);							oW.push(tileSize);							oH.push(countTile * tileSize);														tilesAndDir.push(0);//Vertical = 0							countTile = 0; // Reset the counter						}						if (level[row][column] == 2) //Then we hit a area which has a horizontal tile designated to it						{							tilesAndDir.push(countTile); //Add what we have to the tilesAndDir Array							areaX = column;							areaY = (row - countTile); //Correct Starting Position														oX.push(areaX * tileSize);							oY.push(areaY * tileSize);							oW.push(tileSize);							oH.push(countTile * tileSize);														tilesAndDir.push(0);//Vertical = 0							countTile = 0; // Reset the counter						}					}//End Function - if we have counted 1 or.....									}			}//End of Vertical Map Building For Loop						/*The following piece of Code runs through the level Array horizontallly, counts all the tiles in encounters, logs their starting positions on the map.*/												//Horizontal Map Building - Identical to the Vertical Map Building only it functions Horizontally			for ( var row2:int = 0; row2 < mapHeight; row2++)			{				for ( var column2:int = 0; column2 < mapWidth; column2++)				{					//if there is a tile					if (level[row2][column2] == 2)						{ countTile += 1; } //count how many tiles were in a row										if (column2 == mapWidth - 1) //If row reaches the end of the array in the loop					{						if (countTile >= 1) 						{ 							tilesAndDir.push(countTile);							areaX = (column2 - (countTile - 1));							areaY = row2;														oX.push(areaX * tileSize);							oY.push(areaY * tileSize);							oW.push(countTile * tileSize);							oH.push(tileSize);														tilesAndDir.push(1);//Horizontal							} //Add the number of consequentive tiles to an array called tilesAndDir														countTile = 0; //Reset the tile counter					} //End of Function																				if (countTile >= 1) //If we have a string of tiles					{						if (level[row2][column2] == 0) //Then we hit a area which has no tile designated to it						{							tilesAndDir.push(countTile); //Add what we have to the tilesAndDir Array							areaX = (column2 - countTile);							areaY = row2;														oX.push(areaX * tileSize);							oY.push(areaY * tileSize);							oW.push(countTile * tileSize);							oH.push(tileSize);														tilesAndDir.push(1); //Horizontal							countTile = 0; // Reset the counter						}						if (level[row2][column2] == 1) //Then we hit a area which has a vertical tile designated to it						{							tilesAndDir.push(countTile); //Add what we have to the tilesAndDir Array														areaX = (column2 - countTile);							areaY = row2;														oX.push(areaX * tileSize);							oY.push(areaY * tileSize);							oW.push(countTile * tileSize);							oH.push(tileSize);														tilesAndDir.push(1); //Horizontal							countTile = 0; // Reset the counter						}					}//End Function									}			}//End of Horizontal Map Building For Loop						/*The Following code takes the Map Data created by the Horizontal and Vertical Map Building algorythm. It counts the numberof tiles in each tilesAndDir, then decides the smallest amount of tiles that can represent that tilesAndDir.For example, if we have an tilesAndDir which is 7 tiles in length, we can represent it as one 96pixel tile and one 16pixel tile.It then creates a map using the data it created.*/		var prepTiles:Array = new Array(); //Create the prepTiles Array	var tilesArray:Array = new Array(); //Create the tilesArray for storing the number of tiles which divide into an object	var numberOfTiles:Number = oX.length; //Count the number of Objects			//Builds Tiles using tilesAndDirs defined in the map building algorhytm	for ( var objN:int = 0; objN < numberOfTiles; objN++) //objN = the tilesAndDir number. Which is defined by the order it was created.	{		var numTiles:Number = tilesAndDir[objN * 2]; //Count the number of tiles.		tilesArray= [];//Reset the Array			var six:Number = Math.floor(numTiles / 6); //Divide the number of tiles by 6 and round the result to the nearest floor (ie. 13 / 6 = 2)		var remainder:Number = (numTiles - six * 6); //Find out if there are any number of tiles remainding which weren't divisible by 6 (ie. 6 + 6 + 1 = 13) 1 would be the remainder			for ( var ix:int = 0; ix < six; ix++)		{			tilesArray.push(6); //Save the data		}		if (remainder > 0){tilesArray.push(remainder);} //Save the Remainder Data	//Take the data we find from these alogrythms and use it to deconstruct the positions that these tiles should be placed			var xprev:Number = 0; //Reset the starting position to 0 before running the program		var yprev:Number = 0; //Reset the starting position to 0 before running the program				for ( var iy:int = 0; iy < tilesArray.length; iy++) 		{			var hori:Number = tilesAndDir[objN * 2 + 1] * 6; //If the tile structure is running horizontal, then it is converted to function with the tileSprite Array			//if (hori == 6) {trace("hey its horizontal");}			//Prepate the oTile Array by storing the data in another Array called prepTiles			prepTiles.push(hori + tilesArray[iy] - 1); //Tile Type - Stores the number of the Tile Type			prepTiles.push(oX[objN] + (xprev * tileSize)); //Tile Position X + Displacement if there is more then one tile (xprev)			prepTiles.push(oY[objN] + (yprev * tileSize)); //Tile Position Y + Displacement if there is more then one tile (Displacement called yprev)			//If the tile type is horizontal or vertical change the way you handle the x, y coordinates of tiles			if (hori == 6) {xprev += (tilesArray[iy]);} else {yprev += (tilesArray[iy]);} //Displace the the starting position		}				oTiles.push(prepTiles); //Save the Data		//trace(oTiles[0]);		prepTiles = []; //Clear The Array			}	//CODE THAT objNS THE MAP INTO SEPERATE TILES AND STORES THEM IN THE OTILES ARRAY ENDS HERE!		//Clear Tiles And Directions	tilesAndDir = []; //Empty Memory				//Present the Data			trace("X Positions: " + oX);			trace("Y Positions: " + oY);			trace("W Positions: " + oW);			trace("H Positions: " + oH);						for ( var ii:int = 0; ii < numberOfTiles; ii++)			{ trace("Tile Number: " + ii + " Show Each Tile: " + oTiles[ii]);}						trace("Number of Objects: " + numberOfTiles);												//STAGE TWO - Object based screen movement						//Register Objects to Areas						//Register Objects to their correct Areas			a = []; //Clear all the objects						for ( var n:int = 0; n < numberOfTiles; n++)			{				var xMin:Number = Math.floor(int(oX[n] / sW));				var yMin:Number = Math.floor(int(oY[n] / sH));				var xMax:Number = Math.floor(int((oX[n] + oW[n]) / sW));				var yMax:Number = Math.floor(int((oY[n] + oH[n]) / sH));					trace("obj_n: " + n + " xmin: " + xMin + " ymin: " + yMin + " xmax: " + xMax + " ymax: " + yMax);								for ( var xx:int = xMin; xx <= xMax; xx++){					for ( var yy:int = yMin; yy <= yMax; yy++){								if (a[xx] == undefined){ a[xx] = []; } //If the array hasn't been created, prevent compile crash								if (a[xx][yy] == undefined) { a[xx][yy] = []; } //If the array hasn't been created, prevent compile crash					a[xx][yy][n] = true; //If it is in the Area, set it as true					}				}			}// End Register Objects																	//Start the level by loading in the first screen			ar = []; //-clear the list						for (var bb:String in a[ax][ay]){ //The are in which the top left corner of the screen is in				ar[bb] = true; //Set the object to visible if its in that corner			}			for (var dd:String in a[ax+1][ay]){ //Repeat for each Area				ar[dd] = true;			}			for (var ee:String in a[ax][ay+1]){				ar[ee] = true;			}			for (var ff:String in a[ax+1][ay+1]){				ar[ff] = true;			}					//Check if keys are being pressed		//stage.addEventListener(KeyboardEvent.KEY_DOWN, onKey);		stage.addEventListener(KeyboardEvent.KEY_DOWN, key_down);		stage.addEventListener(KeyboardEvent.KEY_UP, key_up);		//Add Step		addEventListener(Event.ENTER_FRAME, onEnterFrame);				}// END OF FUNCTION												//KEYBOARD KEYS		public function key_down(event:KeyboardEvent):void		{			if (event.keyCode == 32) { press_space = true; }			if (event.keyCode == 37) { press_left = true; }			if (event.keyCode == 38) { press_up = true; }			if (event.keyCode == 39) { press_right = true; }			if (event.keyCode == 40) { press_down = true; }		}		//Check if the key is released		public function key_up(event:KeyboardEvent):void		{			if (event.keyCode == 32) { press_space = false; }			if (event.keyCode == 37) { press_left = false; }			if (event.keyCode == 38) { press_up = false; }			if (event.keyCode == 39) { press_right = false; }			if (event.keyCode == 40) { press_down = false; }		}//END KEYBOARD KEYS FUNCTION												//CREATE TILES		private function createTile(obj):void {						if (v[obj] == undefined) { v[obj] = false; }						if (v[obj] == false) { //Checks to see if it hasnt already been created.			v[obj] = true; //Records that its been built						//Builds the first tile			t[obj] = []; //The object Number - t[obj][number of objects within the object visible]			t[obj][0] = new tileSprite[oTiles[obj][0]]; //Create the new object			t[obj][0].x = oX[obj]; //Place it			t[obj][0].y = oY[obj];			scr.addChild(t[obj][0]); //Add it to the container "scr"						var i:int = oTiles[obj].length / 3;						while(--i)				{				var place:int = i * 3;				t[obj][i] = new tileSprite[oTiles[obj][place]];				t[obj][i].x = int(oTiles[obj][place + 1]);				t[obj][i].y = int(oTiles[obj][place + 2]);				scr.addChild(t[obj][i]);				}						}else { trace("This object already exists"); }					}//END CREATE TILES												//REMOVE TILES		private function removeTile(obj):void {						if (v[obj] == true)//If the tile exists and has been created			{				for (var i:String in t[obj])				{				//trace("objects in array: " + i);				scr.removeChild(t[obj][i]);				t[obj][i] = []; //Clear the memory				v[obj] = []; //Clear the v[0] Memory. Reset Visibility				}			} 			else 			{ trace("this object has already been removed: " + obj);}			//Cleans up Arrays that have empty sets but are still registering.			//Find the objects in the V Array that still exist, copy them into a new Array			for (var g:String in v)				{						if (v[g] == true) { save[g] = true; } //Save them if they exist and are true				}			v = []; // Clear the original Array			for (var f:String in save) // Find all the new values in the saved array			{				v[f] = true; // Put them back in the original Array			}			save = []; //Clear the new array		}//END REMOVE TILES																														//STEP EVENT		private function onEnterFrame(event:Event):void		{			//LEVEL SCROLLING CODE STARTS HERE			sX = int(xPos); //top left of screen: x position			sY = int(yPos); //top left of screen: y position			ax = int(sX / sW); //x cooridinate of the Area which sX, sY is in			ay = int(sY / sH); //y cooridinate of the Area which sX, sY is in						scr.x = sOffx - sX; //Update the scroll	(Move the screen by changing the xPos)			scr.y = sOffy - sY; //Update the scroll						xPos = x_pos - 128;			yPos = y_pos - 98;					mScreen();// Level Scrolling Code Ends Here															//PLAYER CODE STARTS HERE!		walking = false;								//Move left and Right			if (press_left) {				xspeed-=speed;				walking = true;			}			if (press_right) {				xspeed += speed;				walking = true;			}						//If not moving left or right, apply friction			if (!walking) {				xspeed *= friction;				if (int(xspeed)<0.5) {					xspeed = 0;				}			}						//If moving too fast left or right, apply a max_speed			if (xspeed>max_speed) {				xspeed = max_speed;			}			if (xspeed<max_speed*-1) {				xspeed = max_speed*-1;			}										//Place Character		player.x = x_pos;		player.y = y_pos;						//		if (press_space) {			trace(x_pos);			trace(y_pos);						trace(int((x_pos+16)/tileSize) + " right");			trace(int((x_pos)/tileSize) + " left");			trace(int((y_pos+26)/tileSize) + " down");			trace(int((y_pos)/tileSize) + " up");		}				//Move Character		x_pos += xspeed;				get_edges();																						//FPS			time = getTimer();            fps = 1000 / (time - prevTime);            fps_txt.text = "fps: " + fps;            prevTime = getTimer(); 				}//END OF STEP				public function ground_under_feet():void		{			//bonus_speed = 0;			var left_foot_x:int = ((x_pos)/tileSize);			var right_foot_x:int = ((x_pos+16)/tileSize);			var foot_y:int = ((y_pos+26)/tileSize);			var left_foot:Number = level[foot_y][left_foot_x];			var right_foot:Number = level[foot_y][right_foot_x];			if (left_foot != 0) {				current_tile = left_foot;			} else {				current_tile = right_foot;			}			switch (current_tile) {				case 0 :					over = "air"					speed = air_acceleration;					friction = air_friction;					falling = true;					break;				case 1 :					over = "ground";					speed = ground_acceleration;					friction = ground_friction;					break;				case 2 :					over = "ground";					speed = ground_acceleration;					friction = ground_friction;					break;			}		}				public function get_edges():void		{			right = int((x_pos+16)/tileSize);			left = int((x_pos)/tileSize);			bottom = int((y_pos+26)/tileSize);			top = int((y_pos)/tileSize);			top_right = level[top][right];			top_left = level[top][left];			bottom_left = level[bottom][left];			bottom_right = level[bottom][right];		}																																								public function mScreen():void //THIS CODE SCROLLS THE SCREEN		{						var oV = [];//Clear the Visible Array					//Check to see if an object is on scree - Create the object, Flag it as visible		for (var s:String in ar) { //For every object on screen				if ((oX[s] + oW[s]) > sX) { //...check if it's on screen in the x-dimension...						if (oX[s] < (sX + sW)) {								if ((oY[s] + oH[s]) > sY) { //Check if its on screen in the y-dimension..										if (oY[s] < (sY + sH)) {													oV[s] = true; //Set current object to VISIBLE														if (v[s] == undefined) { //If it doesn't already exisit																		createTile(s); //Create the object												}										}								}						}				}		}//End Code				//Register Objects and Delete those that are no longer visible		if (ax == oldax && ay == olday) {//if no new area we delete clips no longer visible				for (var n:String in v) //Check visible objects					{						if (!oV[n]) { //If the object is not on screen but is in the visible area							removeTile(n); //Remove it							break;						}				}		}				else { //- if we have entered a new area, calculate list of objects to check			oldax = ax; //Set area to current Area			olday = ay; //Set area to current Area						ar = []; //-clear the list						//Prevent Crashes			if (a[ax] == undefined){ a[ax] = []; }			if (a[ax][ay] == undefined){ a[ax][ay] = []; trace("no area exisits") }			if (a[ax+1] == undefined){ a[ax+1] = []; }			if (a[ax+1][ay] == undefined){ a[ax+1][ay] = []; trace("no area exisits") }			if (a[ax][ay+1] == undefined){ a[ax][ay+1] = []; trace("no area exisits") }			if (a[ax+1][ay+1] == undefined){ a[ax+1][ay+1] = []; trace("no area exisits") 			}									for (var bb:String in a[ax][ay]){ //The are in which the top left corner of the screen is in				ar[bb] = true; //Set the object to visible if its in that corner			}			for (var dd:String in a[ax+1][ay]){ //Repeat for each Area				ar[dd] = true;			}			for (var ee:String in a[ax][ay+1]){				ar[ee] = true;			}			for (var ff:String in a[ax+1][ay+1]){				ar[ff] = true;			}						} //End code		}//END MSCREEN FUNCTION					}// END OF ALL}